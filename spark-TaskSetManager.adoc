== [[TaskSetManager]] TaskSetManager

`TaskSetManager` is a <<schedulable, Schedulable>> that manages scheduling of tasks in a <<taskSet, TaskSet>>.

NOTE: A link:spark-taskscheduler-tasksets.adoc[TaskSet] represents a set of link:spark-taskscheduler-tasks.adoc[tasks] that correspond to missing link:spark-rdd-partitions.adoc[partitions] of a single link:spark-dagscheduler-stages.adoc[Stage].

NOTE: A task can end <<handleSuccessfulTask, sucessfully>> or due to a <<handleFailedTask, failure>> (in task execution or <<executorLost, an executor being lost>>).

<<creating-instance, `TaskSetManager` is created>> when link:spark-taskschedulerimpl.adoc#createTaskSetManager[`TaskSchedulerImpl` submits tasks (for a given `TaskSet`)].

.TaskSetManager and its Dependencies
image::images/TaskSetManager-TaskSchedulerImpl-TaskSet.png[align="center"]

When <<creating-instance, `TaskSetManager` is created>> for a <<taskSet, TaskSet>>, `TaskSetManager` <<addPendingTask, registers all the tasks as pending execution>>.

`TaskSetManager` uses <<maxTaskFailures, maxTaskFailures>> to control how many times a <<handleFailedTask, single task can fail>> before an <<abort, entire `TaskSet` gets aborted>> that can take the following values:

* `1` for link:spark-local.adoc[`local` run mode]
* `maxFailures` for link:spark-local.adoc[Spark local-with-retries]
* link:spark-taskschedulerimpl.adoc#spark.task.maxFailures[spark.task.maxFailures] property for link:spark-local.adoc[Spark local-cluster] and link:spark-cluster.adoc[Spark clustered] (using Spark Standalone, Mesos and YARN)

The responsibilities of a `TaskSetManager` include:

* <<scheduling-tasks, Scheduling the tasks in a taskset>>
* <<task-retries, Retrying tasks on failure>>
* <<locality-aware-scheduling, Locality-aware scheduling via delay scheduling>>

[TIP]
====
Enable DEBUG logging levels for `org.apache.spark.scheduler.TaskSchedulerImpl` (or `org.apache.spark.scheduler.cluster.YarnScheduler` for YARN) and `org.apache.spark.scheduler.TaskSetManager` and execute the following two-stage job to see their low-level innerworkings.

A cluster manager is recommended since it gives more task localization choices (with YARN additionally supporting rack localization).

```
$ ./bin/spark-shell --master yarn --conf spark.ui.showConsoleProgress=false

// Keep # partitions low to keep # messages low
scala> sc.parallelize(0 to 9, 3).groupBy(_ % 3).count
INFO YarnScheduler: Adding task set 0.0 with 3 tasks
DEBUG TaskSetManager: Epoch for TaskSet 0.0: 0
DEBUG TaskSetManager: Valid locality levels for TaskSet 0.0: NO_PREF, ANY
DEBUG YarnScheduler: parentName: , name: TaskSet_0.0, runningTasks: 0
INFO TaskSetManager: Starting task 0.0 in stage 0.0 (TID 0, 10.0.2.87, executor 1, partition 0, PROCESS_LOCAL, 7541 bytes)
INFO TaskSetManager: Starting task 1.0 in stage 0.0 (TID 1, 10.0.2.87, executor 2, partition 1, PROCESS_LOCAL, 7541 bytes)
DEBUG YarnScheduler: parentName: , name: TaskSet_0.0, runningTasks: 1
INFO TaskSetManager: Starting task 2.0 in stage 0.0 (TID 2, 10.0.2.87, executor 1, partition 2, PROCESS_LOCAL, 7598 bytes)
DEBUG YarnScheduler: parentName: , name: TaskSet_0.0, runningTasks: 1
DEBUG TaskSetManager: No tasks for locality level NO_PREF, so moving to locality level ANY
INFO TaskSetManager: Finished task 0.0 in stage 0.0 (TID 0) in 518 ms on 10.0.2.87 (executor 1) (1/3)
INFO TaskSetManager: Finished task 1.0 in stage 0.0 (TID 1) in 512 ms on 10.0.2.87 (executor 2) (2/3)
DEBUG YarnScheduler: parentName: , name: TaskSet_0.0, runningTasks: 0
INFO TaskSetManager: Finished task 2.0 in stage 0.0 (TID 2) in 51 ms on 10.0.2.87 (executor 1) (3/3)
INFO YarnScheduler: Removed TaskSet 0.0, whose tasks have all completed, from pool
INFO YarnScheduler: Adding task set 1.0 with 3 tasks
DEBUG TaskSetManager: Epoch for TaskSet 1.0: 1
DEBUG TaskSetManager: Valid locality levels for TaskSet 1.0: NODE_LOCAL, RACK_LOCAL, ANY
DEBUG YarnScheduler: parentName: , name: TaskSet_1.0, runningTasks: 0
INFO TaskSetManager: Starting task 0.0 in stage 1.0 (TID 3, 10.0.2.87, executor 2, partition 0, NODE_LOCAL, 7348 bytes)
INFO TaskSetManager: Starting task 1.0 in stage 1.0 (TID 4, 10.0.2.87, executor 1, partition 1, NODE_LOCAL, 7348 bytes)
DEBUG YarnScheduler: parentName: , name: TaskSet_1.0, runningTasks: 1
INFO TaskSetManager: Starting task 2.0 in stage 1.0 (TID 5, 10.0.2.87, executor 1, partition 2, NODE_LOCAL, 7348 bytes)
INFO TaskSetManager: Finished task 1.0 in stage 1.0 (TID 4) in 130 ms on 10.0.2.87 (executor 1) (1/3)
DEBUG YarnScheduler: parentName: , name: TaskSet_1.0, runningTasks: 1
DEBUG TaskSetManager: No tasks for locality level NODE_LOCAL, so moving to locality level RACK_LOCAL
DEBUG TaskSetManager: No tasks for locality level RACK_LOCAL, so moving to locality level ANY
INFO TaskSetManager: Finished task 0.0 in stage 1.0 (TID 3) in 133 ms on 10.0.2.87 (executor 2) (2/3)
DEBUG YarnScheduler: parentName: , name: TaskSet_1.0, runningTasks: 0
INFO TaskSetManager: Finished task 2.0 in stage 1.0 (TID 5) in 21 ms on 10.0.2.87 (executor 1) (3/3)
INFO YarnScheduler: Removed TaskSet 1.0, whose tasks have all completed, from pool
res0: Long = 3
```

====

.TaskSetManager's Internal Registries and Counters
[cols="1,2",options="header",width="100%"]
|===
| Name
| Description

| [[allPendingTasks]] `allPendingTasks`
| Lookup table of the indices of tasks pending execution per executor.

Updated with an task index when `TaskSetManager` <<addPendingTask, registers a task as pending execution (per preferred locations)>>.

| [[calculatedTasks]] `calculatedTasks`
| The number of the tasks that have already completed execution.

Starts from `0` when a <<creating-instance, `TaskSetManager` is created>> and is only incremented when the <<canFetchMoreResults, `TaskSetManager` checks that there is enough memory to fetch a task result>>.

| [[copiesRunning]] `copiesRunning`
| The number of task copies currently running per task (index in its task set).

The number of task copies of a task is increased when <<resourceOffer, dequeuing a task for execution>> or <<checkSpeculatableTasks, checking for speculatable tasks>> and decreased when <<handleFailedTask, a task fails>> or <<executorLost, an executor is lost>> (for a shuffle map stage and no external shuffle service).

| [[currentLocalityIndex]] `currentLocalityIndex`
|

| [[epoch]] `epoch`
| Current link:spark-service-mapoutputtracker.adoc#getEpoch[map output tracker epoch].

| [[failedExecutors]] `failedExecutors`
| Lookup table of TaskInfo's indices that failed to executor ids and the time of the failure.

Used in <<handleFailedTask, handleFailedTask>>.

| [[isZombie]] `isZombie`
| Disabled, i.e. `false`, by default.

Read <<zombie-state, Zombie state>> in this document.

| [[localityWaits]] `localityWaits`
|

| [[myLocalityLevels]] `myLocalityLevels`
| link:spark-taskschedulerimpl.adoc#TaskLocality[`TaskLocality` locality preferences] of the pending tasks in the <<taskSet, TaskSet>> ranging from `PROCESS_LOCAL` through `NODE_LOCAL`, `NO_PREF`, and `RACK_LOCAL` to `ANY`.

NOTE: `myLocalityLevels` may contain only a few of all the available `TaskLocality` preferences with `ANY` as a mandatory task locality preference.

<<computeValidLocalityLevels, Set>> immediately when <<creating-instance, `TaskSetManager` is created>>.

<<recomputeLocality, Recomputed>> every change in the status of executors.

| [[numFailures]] `numFailures`
|

| [[numTasks]] `numTasks`
| Number of <<tasks, tasks>> to compute.

| [[pendingTasksForExecutor]] `pendingTasksForExecutor`
| Lookup table of the indices of tasks pending execution per executor.

Updated with an task index and executor when `TaskSetManager` <<addPendingTask, registers a task as pending execution (per preferred locations)>> (and the location is a `ExecutorCacheTaskLocation` or `HDFSCacheTaskLocation`).

| [[pendingTasksForHost]] `pendingTasksForHost`
| Lookup table of the indices of tasks pending execution per host.

Updated with an task index and host when `TaskSetManager` <<addPendingTask, registers a task as pending execution (per preferred locations)>>.

| [[pendingTasksForRack]] `pendingTasksForRack`
| Lookup table of the indices of tasks pending execution per rack.

Updated with an task index and rack when `TaskSetManager` <<addPendingTask, registers a task as pending execution (per preferred locations)>>.

| [[pendingTasksWithNoPrefs]] `pendingTasksWithNoPrefs`
| Lookup table of the indices of tasks pending execution with no location preferences.

Updated with an task index when `TaskSetManager` <<addPendingTask, registers a task as pending execution (per preferred locations)>>.

| [[recentExceptions]] `recentExceptions`
|

| [[runningTasksSet]] `runningTasksSet`
| Collection of running tasks that a `TaskSetManager` manages.

Used to implement <<runningTasks, runningTasks>> (that is simply the size of `runningTasksSet` but a required part of any link:spark-taskscheduler-schedulable.adoc#contract[Schedulable]). `runningTasksSet` is expanded when <<addRunningTask, registering a running task>> and shrinked when <<removeRunningTask, unregistering a running task>>.

Used in link:spark-taskschedulerimpl.adoc#cancelTasks[`TaskSchedulerImpl` to cancel tasks].

| [[speculatableTasks]] `speculatableTasks`
|

| [[stageId]] `stageId`
| The stage's id a `TaskSetManager` runs for.

Set when <<creating-instance, `TaskSetManager` is created>>.

NOTE: `stageId` is a part of link:spark-taskscheduler-schedulable.adoc#contract[Schedulable contract].

| [[successful]] `successful`
| Status of <<tasks, tasks>> (with a boolean flag, i.e. `true` or `false`, per task).

All tasks start with their flags disabled, i.e. `false`, when <<creating-instance, `TaskSetManager` is created>>.

The flag for a task is turned on, i.e. `true`, when a task finishes <<handleSuccessfulTask, successfully>> but also <<handleFailedTask, with a failure>>.

A flag is explicitly turned off only for <<executorLost, `ShuffleMapTask` tasks when their executor is lost>>.

| [[taskAttempts]] `taskAttempts`
|

| [[taskInfos]] `taskInfos`
| Lookup table of `TaskInfos` per task ids.

Updated with a task (id) and `TaskInfo` when the <<resourceOffer, task is dequeued for execution>>.

NOTE: It _appears_ that the entires stay forever, i.e. are never removed (perhaps because the maintenance overhead is not needed given a `TaskSetManager` is a short-lived entity).

| [[tasks]] `tasks`
| Lookup table of link:spark-taskscheduler-tasks.adoc[Tasks] (per partition id) to schedule execution of.

NOTE: The tasks all belong to a single <<taskSet, TaskSet>> that was given when <<creating-instance, `TaskSetManager` was created>> (which actually represent a single link:spark-dagscheduler-stages.adoc[Stage]).

| [[tasksSuccessful]] `tasksSuccessful`
|

| [[totalResultSize]] `totalResultSize`
| The current total size of the result of all the tasks that have finished.

Starts from `0` when <<creating-instance, `TaskSetManager` is created>>.

Only increased with the size of a task result whenever a `TaskSetManager` <<canFetchMoreResults, checks that there is enough memory to fetch the task result>>.
|===

[TIP]
====
Enable `DEBUG` logging level for `org.apache.spark.scheduler.TaskSetManager` logger to see what happens inside.

Add the following line to `conf/log4j.properties`:

```
log4j.logger.org.apache.spark.scheduler.TaskSetManager=DEBUG
```

Refer to link:spark-logging.adoc[Logging].
====

=== [[getLocalityIndex]] `getLocalityIndex` Method

CAUTION: FIXME

=== [[priority]] `priority` Property

CAUTION: FIXME

=== [[name]] `name` Property

CAUTION: FIXME

=== [[dequeueSpeculativeTask]] `dequeueSpeculativeTask` Method

CAUTION: FIXME

=== [[dequeueTask]] `dequeueTask` Method

CAUTION: FIXME

=== [[executorAdded]] `executorAdded` Method

`executorAdded` simply calls <<recomputeLocality, recomputeLocality>> method.

=== [[abortIfCompletelyBlacklisted]] `abortIfCompletelyBlacklisted` Method

CAUTION: FIXME

=== [[schedulable]] TaskSetManager is Schedulable

`TaskSetManager` is a link:spark-taskscheduler-schedulable.adoc[Schedulable] with the following implementation:

* `name` is `TaskSet_[taskSet.stageId.toString]`
* no `parent` is ever assigned, i.e. it is always `null`.
+
It means that it can only be a leaf in the tree of Schedulables (with link:spark-taskscheduler-pool.adoc[Pools] being the nodes).

* `schedulingMode` always returns `SchedulingMode.NONE` (since there is nothing to schedule).
* `weight` is always `1`.
* `minShare` is always `0`.
* `runningTasks` is the number of running tasks in the internal  `runningTasksSet`.
* `priority` is the priority of the owned link:spark-taskscheduler-tasksets.adoc[TaskSet] (using `taskSet.priority`).
* `stageId` is the stage id of the owned link:spark-taskscheduler-tasksets.adoc[TaskSet] (using `taskSet.stageId`).

* `schedulableQueue` returns no queue, i.e. `null`.
* `addSchedulable` and `removeSchedulable` do nothing.
* `getSchedulableByName` always returns `null`.

* `getSortedTaskSetQueue` returns a one-element collection with the sole element being itself.

* <<executorLost, executorLost>>
* <<checkSpeculatableTasks, checkSpeculatableTasks>>

=== [[handleTaskGettingResult]] Marking Task As Fetching Indirect Result -- `handleTaskGettingResult` Method

[source, scala]
----
handleTaskGettingResult(tid: Long): Unit
----

`handleTaskGettingResult` looks the `TaskInfo` for the task id `tid` up in <<taskInfos, `taskInfos` internal registry>> and marks it as fetching indirect task result. It then link:spark-dagscheduler.adoc#taskGettingResult[notifies `DAGScheduler`].

NOTE: `handleTaskGettingResult` is executed when link:spark-taskschedulerimpl.adoc#handleTaskGettingResult[`TaskSchedulerImpl` is notified about fetching indirect task result].

=== [[addRunningTask]] Registering Running Task -- `addRunningTask` Method

[source, scala]
----
addRunningTask(tid: Long): Unit
----

`addRunningTask` adds `tid` to <<runningTasksSet, runningTasksSet>> internal registry and link:spark-taskscheduler-pool.adoc#increaseRunningTasks[requests the `parent` pool to increase the number of running tasks] (if defined).

=== [[removeRunningTask]] Unregistering Running Task -- `removeRunningTask` Method

[source, scala]
----
removeRunningTask(tid: Long): Unit
----

`removeRunningTask` removes `tid` from <<runningTasksSet, runningTasksSet>> internal registry and link:spark-taskscheduler-pool.adoc#decreaseRunningTasks[requests the `parent` pool to decrease the number of running task] (if defined).

=== [[checkSpeculatableTasks]] Checking Speculatable Tasks -- `checkSpeculatableTasks` Method

NOTE: `checkSpeculatableTasks` is part of the link:spark-taskscheduler-schedulable.adoc#contract[Schedulable Contract].

[source, scala]
----
checkSpeculatableTasks(minTimeToSpeculation: Int): Boolean
----

`checkSpeculatableTasks` checks whether there are speculatable tasks in a `TaskSet`.

NOTE: `checkSpeculatableTasks` is called when link:spark-taskschedulerimpl-speculative-execution.adoc[`TaskSchedulerImpl` checks for speculatable tasks].

If the TaskSetManager is <<zombie-state, zombie>> or has a single task in TaskSet, it assumes no speculatable tasks.

The method goes on with the assumption of no speculatable tasks by default.

It computes the minimum number of finished tasks for speculation (as link:spark-taskschedulerimpl-speculative-execution.adoc#spark_speculation_quantile[spark.speculation.quantile] of all the finished tasks).

You should see the DEBUG message in the logs:

```
DEBUG Checking for speculative tasks: minFinished = [minFinishedForSpeculation]
```

It then checks whether the number is equal or greater than the number of tasks completed successfully (using `tasksSuccessful`).

Having done that, it computes the median duration of all the successfully completed tasks (using <<taskInfos, `taskInfos` internal registry>>) and task length threshold using the median duration multiplied by link:spark-taskschedulerimpl-speculative-execution.adoc#spark_speculation_multiplier[spark.speculation.multiplier] that has to be equal or less than `100`.

You should see the DEBUG message in the logs:

```
DEBUG Task length threshold for speculation: [threshold]
```

For each task (using <<taskInfos, `taskInfos` internal registry>>) that is not marked as successful yet (using `successful`) for which there is only one copy running (using `copiesRunning`) and the task takes more time than the calculated threshold, but it was not in `speculatableTasks` it is assumed *speculatable*.

You should see the following INFO message in the logs:

```
INFO Marking task [index] in stage [taskSet.id] (on [info.host]) as speculatable because it ran more than [threshold] ms
```

The task gets added to the internal `speculatableTasks` collection. The method responds positively.

=== [[resourceOffer]] `resourceOffer` Method

CAUTION: FIXME Review `TaskSetManager.resourceOffer` + Does this have anything related to the following section about scheduling tasks?

[source, scala]
----
resourceOffer(
  execId: String,
  host: String,
  maxLocality: TaskLocality): Option[TaskDescription]
----

When a `TaskSetManager` is a <<zombie-state, zombie>>, `resourceOffer` returns no link:spark-TaskDescription.adoc[TaskDescription] (i.e. `None`).

For a non-zombie `TaskSetManager`, `resourceOffer`...FIXME

CAUTION: FIXME

It dequeues a pending task from the taskset by checking pending tasks per executor (using `pendingTasksForExecutor`), host (using `pendingTasksForHost`), with no localization preferences (using `pendingTasksWithNoPrefs`), rack (uses `TaskSchedulerImpl.getRackForHost` that seems to return "non-zero" value for link:yarn/spark-yarn-yarnscheduler.adoc[YarnScheduler] only)

From `TaskSetManager.resourceOffer`:

```
INFO TaskSetManager: Starting task 0.0 in stage 0.0 (TID 0, 192.168.1.4, partition 0,PROCESS_LOCAL, 1997 bytes)
```

If a serialized task is bigger than `100` kB (it is not a configurable value), a WARN message is printed out to the logs (only once per taskset):

```
WARN TaskSetManager: Stage [task.stageId] contains a task of very large size ([serializedTask.limit / 1024] KB). The maximum recommended task size is 100 KB.
```

A task id is added to `runningTasksSet` set and <<parent-pool, parent pool>> notified (using `increaseRunningTasks(1)` up the chain of pools).

The following INFO message appears in the logs:

```
INFO TaskSetManager: Starting task [id] in stage [taskSet.id] (TID [taskId], [host], partition [task.partitionId],[taskLocality], [serializedTask.limit] bytes)
```

For example:

```
INFO TaskSetManager: Starting task 1.0 in stage 0.0 (TID 1, localhost, partition 1,PROCESS_LOCAL, 2054 bytes)
```

=== [[scheduling-tasks]] Scheduling Tasks in TaskSet

CAUTION: FIXME

For each submitted <<taskset, TaskSet>>, a new TaskSetManager is created. The TaskSetManager completely and exclusively owns a TaskSet submitted for execution.

CAUTION: FIXME A picture with `TaskSetManager` owning TaskSet

CAUTION: FIXME What component knows about TaskSet and TaskSetManager. Isn't it that TaskSets are *created* by  DAGScheduler while TaskSetManager is used by TaskSchedulerImpl only?

TaskSetManager keeps track of the tasks pending execution per executor, host, rack or with no locality preferences.

=== [[locality-aware-scheduling]] Locality-Aware Scheduling aka Delay Scheduling

TaskSetManager computes locality levels for the TaskSet for delay scheduling. While computing you should see the following DEBUG in the logs:

```
DEBUG Valid locality levels for [taskSet]:  [levels]
```

CAUTION: FIXME What's delay scheduling?

=== [[events]] Events

Once a task has finished, `TaskSetManager` informs link:spark-dagscheduler.adoc#taskEnded[DAGScheduler].

CAUTION: FIXME

=== [[handleSuccessfulTask]] Recording Successful Task And Notifying DAGScheduler -- `handleSuccessfulTask` Method

[source, scala]
----
handleSuccessfulTask(tid: Long, result: DirectTaskResult[_]): Unit
----

`handleSuccessfulTask` records the `tid` task as finished, link:spark-dagscheduler.adoc#taskEnded[notifies the `DAGScheduler` that the task has ended] and <<maybeFinishTaskSet, attempts to mark the `TaskSet` finished>>.

NOTE: `handleSuccessfulTask` is executed after link:spark-taskschedulerimpl.adoc#handleSuccessfulTask[`TaskSchedulerImpl` has been informed that `tid` task finished successfully (and the task result was deserialized)].

CAUTION: FIXME Describe `TaskInfo`

Internally, `handleSuccessfulTask` looks `TaskInfo` up (in <<taskInfos, `taskInfos` internal registry>>) and records it as `FINISHED`.

It then removes `tid` task from <<runningTasksSet, runningTasksSet>> internal registry.

`handleSuccessfulTask` link:spark-dagscheduler.adoc#taskEnded[notifies `DAGScheduler` that `tid` task ended successfully] (with the `Task` object from <<tasks, tasks>> internal registry and the result as `Success`).

At this point, `handleSuccessfulTask` looks up the other <<taskAttempts, running task attempts>> of `tid` task and link:spark-SchedulerBackend.adoc#killTask[requests `SchedulerBackend` to kill them]. You should see the following INFO message in the logs:

```
INFO Killing attempt [attemptNumber] for task [id] in stage [id] (TID [id]) on [host] as the attempt [attemptNumber] succeeded on [host]
```

CAUTION: FIXME Review `taskAttempts`

If `tid` has _not_ yet been recorded as <<successful, successful>>, `handleSuccessfulTask` increases <<tasksSuccessful, tasksSuccessful>> counter. You should see the following INFO message in the logs:

```
INFO Finished task [id] in stage [id] (TID [taskId]) in [duration] ms on [host] (executor [executorId]) ([tasksSuccessful]/[numTasks])
```

`tid` task is marked as <<successful, successful>>. If the number of task that have finished successfully is exactly the number of the tasks to execute (in the `TaskSet`), the `TaskSetManager` becomes a <<isZombie, zombie>>.

If `tid` task was already recorded as <<successful, successful>>, you should _merely_ see the following INFO message in the logs:

```
INFO Ignoring task-finished event for [id] in stage [id] because task [index] has already completed successfully
```

Ultimately, `handleSuccessfulTask` <<maybeFinishTaskSet, attempts to mark the `TaskSet` finished>>.

=== [[maybeFinishTaskSet]] Attempting to Mark TaskSet Finished -- `maybeFinishTaskSet` Internal Method

[source, scala]
----
maybeFinishTaskSet(): Unit
----

`maybeFinishTaskSet` link:spark-taskschedulerimpl.adoc#taskSetFinished[notifies `TaskSchedulerImpl` that a `TaskSet` has finished] when there are no other <<runningTasksSet, running tasks>> and the <<isZombie, TaskSetManager is not in zombie state>>.

=== [[handleFailedTask]] `handleFailedTask` Method

[source, scala]
----
handleFailedTask(
  tid: Long,
  state: TaskState,
  reason: TaskFailedReason): Unit
----

`handleFailedTask` <<removeRunningTask, removes `tid` task from the internal registry of running tasks>> and marks `TaskInfo` as finished. It decreases the number of the `tid` task's copies running (in <<copiesRunning, copiesRunning>> internal registry).

NOTE: `handleFailedTask` is executed after link:spark-taskschedulerimpl.adoc#handleFailedTask[`TaskSchedulerImpl` has been informed that `tid` task failed] or <<executorLost, executorLost>>. In either case, tasks could not finish successfully or could not report it back.

NOTE: With link:spark-taskschedulerimpl-speculative-execution.adoc[speculative xecution of tasks] enabled, there can be many copies of a task running simultaneuosly.

When executed, `handleFailedTask` first checks out the status of the `tid` task. If the `tid` task has already been marked as failed or killed (in <<taskInfos, taskInfos>> internal registry), `handleFailedTask` does nothing and quits.

If however the task has not been registered as failed or killed before, `handleFailedTask` <<removeRunningTask, unregisters the task as running>> and marks it as finished with `state`. The number of the running copies of the task (as recorded in <<copiesRunning, `copiesRunning` internal registry>>) is decremented.

CAUTION: FIXME How is `copiesRunning` used?

`handleFailedTask` uses the following pattern as the reason for the failure:

```
Lost task [id] in stage [taskSetId] (TID [tid], [host], executor [executorId]): [reason]
```

`handleFailedTask` then calculates the failure exception for the input `reason`, i.e. <<handleFailedTask-FetchFailed, FetchFailed>>, <<handleFailedTask-ExceptionFailure, ExceptionFailure>>, <<handleFailedTask-ExecutorLostFailure, ExecutorLostFailure>> and <<handleFailedTask-TaskFailedReason, other TaskFailedReasons>>.

NOTE: Calculation of the failure exception was moved to their own sections below to make the reading a bit more pleasant and comprehensible.

`handleFailedTask` link:spark-dagscheduler.adoc#taskEnded[informs `DAGScheduler` that the `tid` task has ended] (with the `Task` instance from <<tasks, tasks>> internal registry, the reason, and no result, i.e. `null`).

If the `tid` task has already been marked as successful (in <<successful, successful>> internal registry) you should see the following INFO message in the logs:

```
INFO Task [id] in stage [id] (TID [tid]) failed, but another instance of the task has already succeeded, so not re-queuing the task to be re-executed.
```

TIP: Refer to link:spark-taskschedulerimpl-speculative-execution.adoc[Speculative Execution of Tasks] to learn why a single task could be executed multiple times at the same time.

If the `tid` task was not recorded as <<successful, successful>>, the task is <<addPendingTask, recorded as a pending task>>.

Unless the `TaskSetManager` is a <<zombie-state, zombie>> or the task failure should _not_ be counted towards the maximum number of times the task is allowed to fail before the stage is aborted (i.e. `TaskFailedReason.countTowardsTaskFailures` is enabled), the optional link:#updateBlacklistForFailedTask[`TaskSetBlacklist` is updated].

`handleFailedTask` increments <<numFailures, numFailures>> for `tid` and makes sure that it is not equal or greater than the allowed number of task failures per `TaskSet` (as specified when the <<creating-instance, `TaskSetManager` was created>>).

If so, i.e. the number of task failures of `tid` reached the maximum value, you should see the following ERROR message in the logs:

```
ERROR Task [id] in stage [id] failed [maxTaskFailures] times; aborting job
```

And `handleFailedTask` <<abort, aborts the `TaskSet`>> and then quits.

In the end, `handleFailedTask` <<maybeFinishTaskSet, attempts to mark the `TaskSet` as finished>>.

CAUTION: FIXME image with `handleFailedTask` (and perhaps the other parties involved)

==== [[handleFailedTask-FetchFailed]] `FetchFailed` TaskFailedReason

For `FetchFailed` you should see the following WARN message in the logs:

```
WARN Lost task [id] in stage [id] (TID [tid], [host], executor [id]): [reason]
```

Unless `tid` has already been marked as successful (in <<successful, successful>> internal registry), it becomes so and the <<tasksSuccessful, number of successful tasks in `TaskSet`>> gets increased.

The `TaskSetManager` enters <<isZombie, zombie state>>.

The failure exception is empty.

==== [[handleFailedTask-ExceptionFailure]] `ExceptionFailure` TaskFailedReason

For `ExceptionFailure`, `handleFailedTask` checks if the exception is of type `NotSerializableException`. If so, you should see the following ERROR message in the logs:

```
ERROR Task [id] in stage [id] (TID [tid]) had a not serializable result: [description]; not retrying
```

And `handleFailedTask` <<abort, aborts the `TaskSet`>> and then quits.

Otherwise, if the exception is not of type `NotSerializableException`, `handleFailedTask` accesses accumulators and calculates whether to print the WARN message (with the failure reason) or the INFO message.

If the failure has already been reported (and is therefore a duplication), <<spark_logging_exceptionPrintInterval, spark.logging.exceptionPrintInterval>> is checked before reprinting the duplicate exception in its entirety.

For full printout of the `ExceptionFailure`, the following WARN appears in the logs:

```
WARN Lost task [id] in stage [id] (TID [tid], [host], executor [id]): [reason]
```

Otherwise, the following INFO appears in the logs:

```
INFO Lost task [id] in stage [id] (TID [tid]) on [host], executor [id]: [className] ([description]) [duplicate [dupCount]]
```

The exception in `ExceptionFailure` becomes the failure exception.

==== [[handleFailedTask-ExecutorLostFailure]] `ExecutorLostFailure` TaskFailedReason

For `ExecutorLostFailure` if not `exitCausedByApp`, you should see the following INFO in the logs:

```
INFO Task [tid] failed because while it was being computed, its executor exited for a reason unrelated to the task. Not counting this failure towards the maximum number of failures for the task.
```

The failure exception is empty.

==== [[handleFailedTask-TaskFailedReason]] Other TaskFailedReasons

For the other TaskFailedReasons, you should see the following WARN message in the logs:

```
WARN Lost task [id] in stage [id] (TID [tid], [host], executor [id]): [reason]
```

The failure exception is empty.

=== [[task-retries]] Retrying Tasks on Failure

CAUTION: FIXME

Up to link:spark-taskschedulerimpl.adoc#spark_task_maxFailures[spark.task.maxFailures] attempts

=== Task retries and `spark.task.maxFailures`

When you start Spark program you set up link:spark-taskschedulerimpl.adoc#spark_task_maxFailures[spark.task.maxFailures] for the number of failures that are acceptable until TaskSetManager gives up and marks a job failed.

TIP: In Spark shell with local master, `spark.task.maxFailures` is fixed to `1` and you need to use link:spark-local.adoc[local-with-retries master] to change it to some other value.

In the following example, you are going to execute a job with two partitions and keep one failing at all times (by throwing an exception). The aim is to learn the behavior of retrying task execution in a stage in TaskSet. You will only look at a single task execution, namely `0.0`.

```
$ ./bin/spark-shell --master "local[*, 5]"
...
scala> sc.textFile("README.md", 2).mapPartitionsWithIndex((idx, it) => if (idx == 0) throw new Exception("Partition 2 marked failed") else it).count
...
15/10/27 17:24:56 INFO DAGScheduler: Submitting 2 missing tasks from ResultStage 1 (MapPartitionsRDD[7] at mapPartitionsWithIndex at <console>:25)
15/10/27 17:24:56 DEBUG DAGScheduler: New pending partitions: Set(0, 1)
15/10/27 17:24:56 INFO TaskSchedulerImpl: Adding task set 1.0 with 2 tasks
...
15/10/27 17:24:56 INFO TaskSetManager: Starting task 0.0 in stage 1.0 (TID 2, localhost, partition 0,PROCESS_LOCAL, 2062 bytes)
...
15/10/27 17:24:56 INFO Executor: Running task 0.0 in stage 1.0 (TID 2)
...
15/10/27 17:24:56 ERROR Executor: Exception in task 0.0 in stage 1.0 (TID 2)
java.lang.Exception: Partition 2 marked failed
...
15/10/27 17:24:56 INFO TaskSetManager: Starting task 0.1 in stage 1.0 (TID 4, localhost, partition 0,PROCESS_LOCAL, 2062 bytes)
15/10/27 17:24:56 INFO Executor: Running task 0.1 in stage 1.0 (TID 4)
15/10/27 17:24:56 INFO HadoopRDD: Input split: file:/Users/jacek/dev/oss/spark/README.md:0+1784
15/10/27 17:24:56 ERROR Executor: Exception in task 0.1 in stage 1.0 (TID 4)
java.lang.Exception: Partition 2 marked failed
...
15/10/27 17:24:56 ERROR Executor: Exception in task 0.4 in stage 1.0 (TID 7)
java.lang.Exception: Partition 2 marked failed
...
15/10/27 17:24:56 INFO TaskSetManager: Lost task 0.4 in stage 1.0 (TID 7) on executor localhost: java.lang.Exception (Partition 2 marked failed) [duplicate 4]
15/10/27 17:24:56 ERROR TaskSetManager: Task 0 in stage 1.0 failed 5 times; aborting job
15/10/27 17:24:56 INFO TaskSchedulerImpl: Removed TaskSet 1.0, whose tasks have all completed, from pool
15/10/27 17:24:56 INFO TaskSchedulerImpl: Cancelling stage 1
15/10/27 17:24:56 INFO DAGScheduler: ResultStage 1 (count at <console>:25) failed in 0.058 s
15/10/27 17:24:56 DEBUG DAGScheduler: After removal of stage 1, remaining stages = 0
15/10/27 17:24:56 INFO DAGScheduler: Job 1 failed: count at <console>:25, took 0.085810 s
org.apache.spark.SparkException: Job aborted due to stage failure: Task 0 in stage 1.0 failed 5 times, most recent failure: Lost task 0.4 in stage 1.0 (TID 7, localhost): java.lang.Exception: Partition 2 marked failed
```

=== [[zombie-state]] Zombie state

A `TaskSetManager` is in *zombie* state when all tasks in a taskset have completed successfully (regardless of the number of task attempts), or if the taskset has been <<abort, aborted>>.

While in zombie state, a `TaskSetManager` can launch no new tasks and <<resourceOffer, responds with no `TaskDescription` to resourceOffers>>.

A `TaskSetManager` remains in the zombie state until all tasks have finished running, i.e. to continue to track and account for the running tasks.

=== [[abort]] Aborting TaskSet -- `abort` Method

[source, scala]
----
abort(message: String, exception: Option[Throwable] = None): Unit
----

`abort` informs link:spark-dagscheduler.adoc#taskSetFailed[`DAGScheduler` that the `TaskSet` has been aborted].

CAUTION: FIXME image with DAGScheduler call

The TaskSetManager enters <<zombie-state, zombie state>>.

Finally, `abort` <<maybeFinishTaskSet, attempts to mark the `TaskSet` finished>>.

=== [[canFetchMoreResults]] Checking Available Memory For Task Result -- `canFetchMoreResults` Method

[source, scala]
----
canFetchMoreResults(size: Long): Boolean
----

`canFetchMoreResults` checks whether there is enough memory to fetch the result of a task.

Internally, `canFetchMoreResults` increments the internal <<totalResultSize, totalResultSize>> with the input `size` which is the result of a task. It also increments the internal <<calculatedTasks, calculatedTasks>>.

If the current internal <<totalResultSize, totalResultSize>> is bigger than  <<spark_driver_maxResultSize, spark.driver.maxResultSize>> the following ERROR message is printed out to the logs:

```
ERROR TaskSetManager: Total size of serialized results of [calculatedTasks] tasks ([totalResultSize]) is bigger than spark.driver.maxResultSize ([maxResultSize])
```

The current link:spark-taskscheduler-tasksets.adoc[TaskSet] is <<abort, aborted>> and `canFetchMoreResults` returns `false`.

Otherwise, `canFetchMoreResults` returns `true`.

NOTE: `canFetchMoreResults` is used in link:spark-taskschedulerimpl-TaskResultGetter.adoc#enqueueSuccessfulTask[TaskResultGetter.enqueueSuccessfulTask] only.

=== [[creating-instance]] Creating TaskSetManager Instance

`TaskSetManager` takes the following when created:

* [[sched]] link:spark-taskschedulerimpl.adoc[TaskSchedulerImpl]
* [[taskSet]] link:spark-taskscheduler-tasksets.adoc[TaskSet] that the `TaskSetManager` manages scheduling for
* [[maxTaskFailures]] `maxTaskFailures` -- how many times a <<handleFailedTask, single task can fail>> before an <<abort, entire `TaskSet` gets aborted>>.
* [[blacklistTracker]] (optional) BlacklistTracker
* [[clock]] `Clock` (defaults to `SystemClock`)

`TaskSetManager` initializes the <<internal-registries, internal registries and counters>>.

NOTE: `maxTaskFailures` is `1` for `local` run mode, `maxFailures` for Spark local-with-retries, and link:spark-taskschedulerimpl.adoc#spark.task.maxFailures[spark.task.maxFailures] property for Spark local-cluster and Spark with cluster managers (Spark Standalone, Mesos and YARN).

`TaskSetManager` link:spark-service-mapoutputtracker.adoc#getEpoch[requests the current epoch from `MapOutputTracker`] and sets it on all tasks in the taskset.

NOTE: `TaskSetManager` uses <<sched, TaskSchedulerImpl>> (that was given when <<creating-instance, created>>) to link:spark-taskschedulerimpl.adoc#mapOutputTracker[access the current `MapOutputTracker`].

You should see the following DEBUG in the logs:

```
DEBUG Epoch for [taskSet]: [epoch]
```

CAUTION: FIXME Why is the epoch important?

NOTE: `TaskSetManager` requests link:spark-taskschedulerimpl.adoc#mapOutputTracker[`MapOutputTracker` from `TaskSchedulerImpl`] which is _likely_ for unit testing only since link:spark-sparkenv.adoc#mapOutputTracker[`MapOutputTracker` is available using `SparkEnv`].

`TaskSetManager` <<addPendingTask, adds the tasks as pending execution>> (in reverse order from the highest partition to the lowest).

CAUTION: FIXME Why is reverse order important? The code says it's to execute tasks with low indices first.

=== [[addPendingTask]] Registering Task As Pending Execution (Per Preferred Locations) -- `addPendingTask` Internal Method

[source, scala]
----
addPendingTask(index: Int): Unit
----

`addPendingTask` registers a `index` task in the pending-task lists that the task should be eventually scheduled to (per its preferred locations).

Internally, `addPendingTask` takes the link:spark-taskscheduler-tasks.adoc#preferredLocations[preferred locations of the task] (given `index`) and registers the task in the internal pending-task registries for every preferred location:

* <<pendingTasksForExecutor, pendingTasksForExecutor>> when the `TaskLocation` is `ExecutorCacheTaskLocation`.
* <<pendingTasksForHost, pendingTasksForHost>> for the hosts of a `TaskLocation`.
* <<pendingTasksForRack, pendingTasksForRack>> for the link:spark-taskschedulerimpl.adoc#getRackForHost[racks from  `TaskSchedulerImpl` per the host] (of a `TaskLocation`).

For a `TaskLocation` being `HDFSCacheTaskLocation`, `addPendingTask` link:spark-taskschedulerimpl.adoc#getExecutorsAliveOnHost[requests `TaskSchedulerImpl` for the executors on the host] (of a preferred location) and registers the task in <<pendingTasksForExecutor, pendingTasksForExecutor>> for every executor (if available).

You should see the following INFO message in the logs:

```
INFO Pending task [index] has a cached location at [host] , where there are executors [executors]
```

When `addPendingTask` could not find executors for a `HDFSCacheTaskLocation` preferred location, you should see the following DEBUG message in the logs:

```
DEBUG Pending task [index] has a cached location at [host] , but there are no executors alive there.
```

If the task has no location preferences, `addPendingTask` registers it in <<pendingTasksWithNoPrefs, pendingTasksWithNoPrefs>>.

`addPendingTask` always registers the task in <<allPendingTasks, allPendingTasks>>.

NOTE: `addPendingTask` is used immediatelly when `TaskSetManager` <<creating-instance, is created>> and later when handling a <<handleFailedTask, task failure>> or <<executorLost, lost executor>>.

=== [[executorLost]] Re-enqueuing ShuffleMapTasks (with no ExternalShuffleService) and Reporting All Running Tasks on Lost Executor as Failed -- `executorLost` Method

[source, scala]
----
executorLost(execId: String, host: String, reason: ExecutorLossReason): Unit
----

`executorLost` re-enqueues all the link:spark-taskscheduler-ShuffleMapTask.adoc[ShuffleMapTasks] that have completed already on the lost executor (when link:spark-ExternalShuffleService.adoc[external shuffle service] is not in use) and <<handleFailedTask, reports all currently-running tasks on the lost executor as failed>>.

NOTE: `executorLost` is a part of the link:spark-taskscheduler-schedulable.adoc#contract[Schedulable contract] that link:spark-taskschedulerimpl.adoc#removeExecutor[`TaskSchedulerImpl` uses to inform `TaskSetManagers` about lost executors].

NOTE: Since `TaskSetManager` manages execution of the tasks in a single link:spark-taskscheduler-tasksets.adoc[TaskSet], when an executor gets lost, the affected tasks that have been running on the failed executor need to be re-enqueued. `executorLost` is the mechanism to "announce" the event to all `TaskSetManagers`.

Internally, `executorLost` first checks whether the <<tasks, tasks>> are link:spark-taskscheduler-ShuffleMapTask.adoc[ShuffleMapTasks] and whether an link:spark-ExternalShuffleService.adoc[external shuffle service] is enabled (that could serve the map shuffle outputs in case of failure).

NOTE: `executorLost` checks out the first task in <<tasks, tasks>> as it is assumed the other belong to the same stage. If the task is a link:spark-taskscheduler-ShuffleMapTask.adoc[ShuffleMapTask], the entire <<taskSet, TaskSet>> is for a link:spark-dagscheduler-ShuffleMapStage.adoc[ShuffleMapStage].

NOTE: `executorLost` uses link:spark-sparkenv.adoc#blockManager[`SparkEnv` to access the current `BlockManager`] and finds out whether an link:spark-blockmanager.adoc#externalShuffleServiceEnabled[external shuffle service is enabled] or not (that is controlled using link:spark-ExternalShuffleService.adoc#spark.shuffle.service.enabled[spark.shuffle.service.enabled] property).

If `executorLost` is indeed due to an executor lost that executed tasks for a link:spark-dagscheduler-ShuffleMapStage.adoc[ShuffleMapStage] (that this `TaskSetManager` manages) and no external shuffle server is enabled, `executorLost` finds <<taskInfos, all the tasks>> that were scheduled on this lost executor and marks the <<successful, ones that were already successfully completed>> as not executed yet.

NOTE: `executorLost` uses records every tasks on the lost executor in <<successful, successful>> (as `false`) and decrements <<copiesRunning copiesRunning>>, and <<tasksSuccessful, tasksSuccessful>> for every task.

`executorLost` <<addPendingTask, registers every task as pending execution (per preferred locations)>> and link:spark-dagscheduler.adoc#taskEnded[informs `DAGScheduler` that the tasks (on the lost executor) have ended] (with link:spark-dagscheduler.adoc#handleTaskCompletion-Resubmitted[Resubmitted] reason).

NOTE: `executorLost` uses link:spark-taskschedulerimpl.adoc#dagScheduler[`TaskSchedulerImpl` to access the `DAGScheduler`]. `TaskSchedulerImpl` is given when the <<creating-instance, `TaskSetManager` was created>>.

Regardless of whether this `TaskSetManager` manages `ShuffleMapTasks` or not (it could also manage link:spark-taskscheduler-ResultTask.adoc[ResultTasks]) and whether the external shuffle service is used or not, `executorLost` finds all <<taskInfos, currently-running tasks>> on this lost executor and <<handleFailedTask, reports them as failed>> (with the task state `FAILED`).

NOTE: `executorLost` finds out if the reason for the executor lost is due to application fault, i.e. assumes ``ExecutorExited``'s exit status as the indicator, `ExecutorKilled` for non-application's fault and any other reason is an application fault.

`executorLost` <<recomputeLocality, recomputes locality preferences>>.

=== [[recomputeLocality]] Recomputing Task Locality Preferences -- `recomputeLocality` Method

[source, scala]
----
recomputeLocality(): Unit
----

`recomputeLocality` recomputes the internal caches: <<myLocalityLevels, myLocalityLevels>>, <<localityWaits, localityWaits>> and <<currentLocalityIndex, currentLocalityIndex>>.

CAUTION: FIXME But *why* are the caches important (and have to be recomputed)?

`recomputeLocality` records the current link:spark-taskschedulerimpl.adoc#TaskLocality[TaskLocality] level of this `TaskSetManager` (that is <<currentLocalityIndex, currentLocalityIndex>> in <<myLocalityLevels, myLocalityLevels>>).

NOTE: `TaskLocality` is one of `PROCESS_LOCAL`, `NODE_LOCAL`, `NO_PREF`, `RACK_LOCAL` and `ANY` values.

`recomputeLocality` <<computeValidLocalityLevels, computes locality levels (for scheduled tasks)>> and saves the result in <<myLocalityLevels, myLocalityLevels>> internal cache.

`recomputeLocality` computes <<localityWaits, localityWaits>> (by <<getLocalityWait, finding locality wait>> for every locality level in <<myLocalityLevels, myLocalityLevels>> internal cache).

In the end, `recomputeLocality` <<getLocalityIndex, getLocalityIndex>> of the previous locality level and records it in <<currentLocalityIndex, currentLocalityIndex>>.

NOTE: `recomputeLocality` is used when `TaskSetManager` gets notified about status change in executors, i.e. when an executor is <<executorLost, lost>> or <<executorAdded, added>>.

=== [[computeValidLocalityLevels]] Computing Locality Levels (for Scheduled Tasks) -- `computeValidLocalityLevels` Internal Method

[source, scala]
----
computeValidLocalityLevels(): Array[TaskLocality]
----

`computeValidLocalityLevels` computes valid locality levels for tasks that were registered in corresponding registries per locality level.

NOTE: link:spark-taskschedulerimpl.adoc[TaskLocality] is a task locality preference and can be the most localized `NODE_LOCAL` through `NO_PREF` and `RACK_LOCAL` to `ANY`.

.TaskLocalities and Corresponding Internal Registries
[cols="1,2",options="header",width="100%"]
|===
| TaskLocality
| Internal Registry

| `PROCESS_LOCAL`
| <<pendingTasksForExecutor, pendingTasksForExecutor>>
| `NODE_LOCAL`
| <<pendingTasksForHost, pendingTasksForHost>>
| `NO_PREF`
| <<pendingTasksWithNoPrefs, pendingTasksWithNoPrefs>>
| `RACK_LOCAL`
| <<pendingTasksForRack, pendingTasksForRack>>

|===

`computeValidLocalityLevels` walks over every internal registry and if it is not empty <<getLocalityWait, computes locality wait>> for the corresponding `TaskLocality` and proceeds with it only when the locality wait is not `0`.

For `TaskLocality` with pending tasks, `computeValidLocalityLevels` asks `TaskSchedulerImpl` whether there is at least one executor alive (for link:spark-taskschedulerimpl.adoc#isExecutorAlive[PROCESS_LOCAL], link:spark-taskschedulerimpl.adoc#hasExecutorsAliveOnHost[NODE_LOCAL] and link:spark-taskschedulerimpl.adoc#hasHostAliveOnRack[RACK_LOCAL]) and if so registers the `TaskLocality`.

NOTE: `computeValidLocalityLevels` uses <<sched, TaskSchedulerImpl>> that was given when <<TaskSetManager, `TaskSetManager` was created>>.

`computeValidLocalityLevels` always registers `ANY` task locality level.

In the end, you should see the following DEBUG message in the logs:

```
DEBUG TaskSetManager: Valid locality levels for [taskSet]: [comma-separated levels]
```

NOTE: `computeValidLocalityLevels` is used when `TaskSetManager` <<creating-instance, is created>> and later to <<recomputeLocality, recompute locality>>.

=== [[getLocalityWait]] Finding Locality Wait -- `getLocalityWait` Internal Method

[source, scala]
----
getLocalityWait(level: TaskLocality): Long
----

`getLocalityWait` finds *locality wait* (in milliseconds) for a given link:spark-taskschedulerimpl.adoc#TaskLocality[TaskLocality].

`getLocalityWait` uses <<spark.locality.wait, spark.locality.wait>> (default: `3s`) when the ``TaskLocality``-specific property is not defined or `0` for `NO_PREF` and `ANY`.

NOTE: `NO_PREF` and `ANY` task localities have no locality wait.

.TaskLocalities and Corresponding Spark Properties
[cols="1,2",options="header",width="100%"]
|===
| TaskLocality
| Spark Property

| PROCESS_LOCAL
| <<spark.locality.wait.process, spark.locality.wait.process>>

| NODE_LOCAL
| <<spark.locality.wait.node, spark.locality.wait.node>>

| RACK_LOCAL
| <<spark.locality.wait.rack, spark.locality.wait.rack>>
|===

NOTE: `getLocalityWait` is used when `TaskSetManager` calculates <<localityWaits, localityWaits>>, <<computeValidLocalityLevels, computes locality levels (for scheduled tasks)>> and <<recomputeLocality, recomputes locality preferences>>.

=== [[settings]] Settings

.Spark Properties
[cols="1,1,2",options="header",width="100%"]
|===
| Spark Property
| Default Value
| Description

| [[spark_driver_maxResultSize]] `spark.driver.maxResultSize`
| `1g`
| The maximum size of all the task results in a `TaskSet`. If the value is smaller than `1m` or `1048576` (1024 * 1024), it is considered `0`.

Used when <<canFetchMoreResults, `TaskSetManager` checks available memory for a task result>> and `Utils.getMaxResultSize`.

| `spark.scheduler.executorTaskBlacklistTime`
| `0L`
| Time interval to pass after which a task can be re-launched on the executor where it has once failed. It is to prevent repeated task failures due to executor failures.

| [[spark_logging_exceptionPrintInterval]] `spark.logging.exceptionPrintInterval`
| `10000`
| How frequently to reprint duplicate exceptions in full (in millis).

| [[spark.locality.wait]] `spark.locality.wait`
| `3s`
| For locality-aware delay scheduling for `PROCESS_LOCAL`, `NODE_LOCAL`, and `RACK_LOCAL` link:spark-taskschedulerimpl.adoc#TaskLocality[TaskLocalities] when locality-specific setting is not set.

| [[spark.locality.wait.process]] `spark.locality.wait.process`
| The value of <<spark.locality.wait, spark.locality.wait>>
| Scheduling delay for `PROCESS_LOCAL` link:spark-taskschedulerimpl.adoc#TaskLocality[TaskLocality]

| [[spark.locality.wait.node]] `spark.locality.wait.node`
| The value of <<spark.locality.wait, spark.locality.wait>>
| Scheduling delay for `NODE_LOCAL` link:spark-taskschedulerimpl.adoc#TaskLocality[TaskLocality]

| [[spark.locality.wait.rack]] `spark.locality.wait.rack`
| The value of <<spark.locality.wait, spark.locality.wait>>
| Scheduling delay for `RACK_LOCAL` link:spark-taskschedulerimpl.adoc#TaskLocality[TaskLocality]
|===
